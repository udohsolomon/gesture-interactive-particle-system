<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GESTURE PARTICLES // FACE + HAND TRACKER v3</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: #0a1015;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            user-select: none;
            cursor: crosshair;
            min-height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
        }

        #lines-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 0;
            pointer-events: none;
        }

        #camera-container {
            position: fixed;
            top: 20px; right: 20px;
            width: 200px; height: 150px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        #camera-container.hidden { display: none; }

        #input-video {
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #overlay-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            transform: scaleX(-1);
        }

        .hud {
            position: fixed;
            color: #00FFFF;
            text-shadow: 0 0 10px #00FFFF;
            z-index: 5;
            padding: 15px;
            font-size: 12px;
            letter-spacing: 2px;
            pointer-events: none;
        }

        .hud-bl {
            bottom: 20px; left: 20px;
            border-bottom: 2px solid #00FFFF;
            border-left: 2px solid #00FFFF;
        }

        .data-label {
            font-family: 'Share Tech Mono', monospace;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 2px;
        }

        .data-val { font-weight: 700; font-size: 14px; }
        .data-row { margin-bottom: 10px; }

        .controls {
            position: fixed;
            top: 20px; left: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn {
            padding: 8px 16px;
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00FFFF;
            color: #00FFFF;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .btn.active { background: #00FFFF; color: #000; }

        .status-indicator {
            position: fixed;
            top: 20px; right: 240px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 12px;
            color: #00FF88;
        }

        .status-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #00FF88;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .theme-indicator {
            position: fixed;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: #00FFFF;
            text-shadow: 0 0 10px currentColor;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .effect-indicator {
            position: fixed;
            bottom: 50px; left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            color: #FFD700;
            text-shadow: 0 0 20px currentColor;
            text-transform: uppercase;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .effect-indicator.show {
            opacity: 1;
        }

        .shortcuts {
            position: fixed;
            bottom: 20px; right: 20px;
            z-index: 10;
            font-family: 'Share Tech Mono', monospace;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            text-align: right;
        }

        .shortcuts div { margin-bottom: 3px; }
        .shortcuts span { color: #00FFFF; }

        #loading {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #0a1015;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            color: #00FFFF;
            font-size: 18px;
            letter-spacing: 3px;
        }

        #loading .spinner {
            width: 50px; height: 50px;
            border: 3px solid rgba(0, 255, 255, 0.2);
            border-top-color: #00FFFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 40%, rgba(0, 0, 0, 0.7) 100%);
            z-index: 2;
        }

        .audio-indicator {
            position: fixed;
            bottom: 80px; right: 20px;
            z-index: 10;
            display: flex;
            align-items: flex-end;
            gap: 3px;
            height: 30px;
        }

        .audio-bar {
            width: 4px;
            background: #00FFFF;
            transition: height 0.05s;
        }
    </style>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div>INITIALIZING NEURAL LINK...</div>
    </div>

    <canvas id="lines-canvas"></canvas>
    <div id="canvas-container"></div>
    <div class="vignette"></div>

    <div id="camera-container">
        <video id="input-video" playsinline></video>
        <canvas id="overlay-canvas"></canvas>
    </div>

    <div class="controls">
        <button class="btn active" id="btn-attract">Attract Mode</button>
        <button class="btn" id="btn-spiral">Spiral: OFF</button>
        <button class="btn" id="btn-trails">Trails: ON</button>
        <button class="btn" id="btn-lines">Lines: OFF</button>
        <button class="btn" id="btn-audio">Audio: OFF</button>
        <button class="btn active" id="btn-sfx">SFX: ON</button>
        <button class="btn" id="btn-camera">Hide Camera</button>
    </div>

    <div class="status-indicator" id="status">
        <div class="status-dot"></div>
        <span id="detection-status">Initializing...</span>
    </div>

    <div class="effect-indicator" id="effect-indicator"></div>
    <div class="theme-indicator" id="theme-name">RAINBOW</div>

    <div class="hud hud-bl">
        <div class="data-row">
            <div class="data-label">PARTICLES</div>
            <div class="data-val">12,000</div>
        </div>
        <div class="data-row">
            <div class="data-label">FPS</div>
            <div class="data-val" id="fps">0</div>
        </div>
        <div class="data-row">
            <div class="data-label">GESTURE</div>
            <div class="data-val" id="gesture">NONE</div>
        </div>
    </div>

    <div class="audio-indicator" id="audio-indicator" style="display: none;">
        <div class="audio-bar" style="height: 5px;"></div>
        <div class="audio-bar" style="height: 5px;"></div>
        <div class="audio-bar" style="height: 5px;"></div>
        <div class="audio-bar" style="height: 5px;"></div>
        <div class="audio-bar" style="height: 5px;"></div>
        <div class="audio-bar" style="height: 5px;"></div>
        <div class="audio-bar" style="height: 5px;"></div>
        <div class="audio-bar" style="height: 5px;"></div>
    </div>

    <div class="shortcuts">
        <div><span>SPACE</span> Toggle mode</div>
        <div><span>S</span> Toggle spiral</div>
        <div><span>T</span> Toggle trails</div>
        <div><span>L</span> Toggle lines</div>
        <div><span>A</span> Toggle audio</div>
        <div><span>M</span> Toggle SFX</div>
        <div><span>V</span> Toggle camera</div>
        <div><span>CLICK</span> Explosion</div>
    </div>

    <script>
        // ========================================
        // CONFIGURATION
        // ========================================
        const CONFIG = {
            particleCount: 12000,
            lerpSpeed: 0.18,
            attractRadius: 200,
            repelForce: 100,
            trailLength: 8,
            connectionDistance: 25,
            maxConnections: 500,
            pulseSpeed: 2.5,
            sparkleChance: 0.002,
            spiralSpeed: 0.8,
            explosionForce: 300,
            explosionDecay: 0.92
        };

        // Color Themes
        const THEMES = [
            {
                name: 'RAINBOW',
                getColor: (i, time, audioLevel) => {
                    const hue = (i * 0.0003 + time * 0.1 + audioLevel * 0.3) % 1;
                    return hsvToRgb(hue, 0.9, 1.0);
                }
            },
            {
                name: 'FIRE',
                getColor: (i, time, audioLevel) => {
                    const t = (Math.sin(i * 0.01 + time + audioLevel * 2) + 1) / 2;
                    return lerpColors([[1, 0.27, 0], [1, 0.55, 0], [1, 0.84, 0]], t);
                }
            },
            {
                name: 'OCEAN',
                getColor: (i, time, audioLevel) => {
                    const t = (Math.sin(i * 0.01 + time + audioLevel) + 1) / 2;
                    return lerpColors([[0, 0.4, 1], [0, 1, 1], [0, 0.81, 0.82]], t);
                }
            },
            {
                name: 'GALAXY',
                getColor: (i, time, audioLevel) => {
                    const t = (Math.sin(i * 0.01 + time * 0.5 + audioLevel * 1.5) + 1) / 2;
                    return lerpColors([[0.58, 0, 0.83], [1, 0, 1], [0.25, 0.41, 0.88]], t);
                }
            },
            {
                name: 'MATRIX',
                getColor: (i, time, audioLevel) => {
                    const brightness = 0.6 + Math.sin(i * 0.02 + time * 2) * 0.4 + audioLevel * 0.3;
                    return [0, Math.min(brightness, 1), 0];
                }
            }
        ];

        function hsvToRgb(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return [r, g, b];
        }

        function lerpColors(colors, t) {
            const idx = t * (colors.length - 1);
            const i = Math.floor(idx);
            const f = idx - i;
            const c1 = colors[Math.min(i, colors.length - 1)];
            const c2 = colors[Math.min(i + 1, colors.length - 1)];
            return [
                c1[0] + (c2[0] - c1[0]) * f,
                c1[1] + (c2[1] - c1[1]) * f,
                c1[2] + (c2[2] - c1[2]) * f
            ];
        }

        // ========================================
        // STATE
        // ========================================
        const state = {
            mode: 'ATTRACT',
            themeIndex: 0,
            themeCooldown: 0,
            time: 0,
            targetPoints: [],
            handsDetected: 0,
            faceDetected: false,
            cameraVisible: true,
            initialized: false,
            // New effect states
            trailsEnabled: true,
            spiralEnabled: false,
            linesEnabled: false,
            audioEnabled: false,
            sfxEnabled: true,
            audioLevel: 0,
            explosions: [],
            sparkles: new Set(),
            pulsePhase: 0,
            currentGesture: 'NONE',
            mouthOpen: false,
            peaceSign: false,
            gestureCooldown: 0
        };

        // Velocity tracking for trails
        const velocities = new Float32Array(CONFIG.particleCount * 3);
        const prevPositions = new Float32Array(CONFIG.particleCount * 3);

        // ========================================
        // THREE.JS SETUP
        // ========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 300;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x0a1015, 1);
        container.appendChild(renderer.domElement);

        // Lines canvas for connection lines
        const linesCanvas = document.getElementById('lines-canvas');
        const linesCtx = linesCanvas.getContext('2d');
        linesCanvas.width = window.innerWidth;
        linesCanvas.height = window.innerHeight;

        // ========================================
        // PARTICLE SYSTEM
        // ========================================
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const colors = new Float32Array(CONFIG.particleCount * 3);
        const sizes = new Float32Array(CONFIG.particleCount);

        // Initialize particles scattered
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            positions[i3] = (Math.random() - 0.5) * 600;
            positions[i3 + 1] = (Math.random() - 0.5) * 400;
            positions[i3 + 2] = (Math.random() - 0.5) * 100;

            prevPositions[i3] = positions[i3];
            prevPositions[i3 + 1] = positions[i3 + 1];
            prevPositions[i3 + 2] = positions[i3 + 2];

            colors[i3] = 0;
            colors[i3 + 1] = 1;
            colors[i3 + 2] = 1;

            sizes[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Enhanced vertex shader with trails support
        const vertexShader = `
            attribute float size;
            varying vec3 vColor;
            varying float vSize;
            uniform float uPulse;
            uniform float uTime;

            void main() {
                vColor = color;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

                // Pulse effect
                float pulse = 1.0 + sin(uTime * 2.5 + float(gl_VertexID) * 0.01) * 0.3 * uPulse;

                float baseSize = (2.5 + size * 2.5) * pulse;
                gl_PointSize = baseSize * (200.0 / -mvPosition.z);
                gl_PointSize = clamp(gl_PointSize, 1.5, 15.0);
                vSize = gl_PointSize;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // Enhanced fragment shader with sparkle
        const fragmentShader = `
            varying vec3 vColor;
            varying float vSize;
            uniform float uTime;

            void main() {
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                float r2 = dot(cxy, cxy);
                if (r2 > 1.0) discard;

                float brightness = exp(-r2 * 2.5);
                float core = exp(-r2 * 8.0);

                // Sparkle effect
                float sparkle = sin(uTime * 20.0 + gl_FragCoord.x * 0.1 + gl_FragCoord.y * 0.1) * 0.5 + 0.5;
                sparkle = pow(sparkle, 8.0) * 0.5;

                vec3 finalColor = vColor * brightness * 1.3 + vec3(core * 0.8 + sparkle);
                gl_FragColor = vec4(finalColor, brightness * 1.2);
            }
        `;

        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                uPulse: { value: 1.0 },
                uTime: { value: 0.0 }
            },
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true,
            vertexColors: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Trail lines
        const trailGeometry = new THREE.BufferGeometry();
        const trailPositions = new Float32Array(CONFIG.particleCount * 6); // 2 points per line
        const trailColors = new Float32Array(CONFIG.particleCount * 6);
        trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
        trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));

        const trailMaterial = new THREE.LineBasicMaterial({
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.4
        });

        const trails = new THREE.LineSegments(trailGeometry, trailMaterial);
        scene.add(trails);

        // ========================================
        // AUDIO SETUP
        // ========================================
        let audioContext = null;
        let analyser = null;
        let audioData = null;
        let sfxContext = null; // Separate context for sound effects

        // Initialize sound effects context
        function initSFX() {
            if (!sfxContext) {
                sfxContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return sfxContext;
        }

        // Sound effect functions
        function playTone(frequency, duration, type = 'sine', volume = 0.3) {
            if (!state.sfxEnabled) return;
            const ctx = initSFX();
            if (ctx.state === 'suspended') ctx.resume();

            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            gainNode.gain.setValueAtTime(volume, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + duration);
        }

        function playExplosionSound() {
            if (!state.sfxEnabled) return;
            const ctx = initSFX();
            if (ctx.state === 'suspended') ctx.resume();

            // White noise burst for explosion
            const bufferSize = ctx.sampleRate * 0.3;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
            }

            const noise = ctx.createBufferSource();
            noise.buffer = buffer;

            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 500;

            const gainNode = ctx.createGain();
            gainNode.gain.setValueAtTime(0.4, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);

            noise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(ctx.destination);

            noise.start();
        }

        function playThemeSound(themeIndex) {
            if (!state.sfxEnabled) return;
            // Musical notes for each theme
            const notes = [523.25, 587.33, 659.25, 783.99, 880]; // C5, D5, E5, G5, A5
            playTone(notes[themeIndex], 0.3, 'sine', 0.25);
            setTimeout(() => playTone(notes[themeIndex] * 1.5, 0.2, 'sine', 0.15), 100);
        }

        function playFireworksSound() {
            if (!state.sfxEnabled) return;
            const ctx = initSFX();
            if (ctx.state === 'suspended') ctx.resume();

            // Multiple sparkle tones
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    if (state.sfxEnabled) playTone(1000 + Math.random() * 2000, 0.15, 'sine', 0.1);
                }, i * 80);
            }
        }

        function playModeSound(isAttract) {
            if (!state.sfxEnabled) return;
            if (isAttract) {
                // Rising tone for attract
                playTone(300, 0.15, 'sine', 0.2);
                setTimeout(() => playTone(400, 0.15, 'sine', 0.2), 50);
                setTimeout(() => playTone(500, 0.15, 'sine', 0.2), 100);
            } else {
                // Falling tone for repel
                playTone(500, 0.15, 'sine', 0.2);
                setTimeout(() => playTone(400, 0.15, 'sine', 0.2), 50);
                setTimeout(() => playTone(300, 0.15, 'sine', 0.2), 100);
            }
        }

        function playGestureSound(gesture) {
            if (!state.sfxEnabled) return;
            switch(gesture) {
                case 'FIST':
                    playTone(440, 0.1, 'square', 0.15);
                    break;
                case 'PEACE':
                    playTone(660, 0.1, 'sine', 0.2);
                    setTimeout(() => playTone(880, 0.1, 'sine', 0.2), 50);
                    break;
                case 'MOUTH OPEN':
                    // Whoosh sound
                    const ctx = initSFX();
                    if (ctx.state === 'suspended') ctx.resume();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.15, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                    osc.start();
                    osc.stop(ctx.currentTime + 0.2);
                    break;
            }
        }

        function playSpiralSound() {
            if (!state.sfxEnabled) return;
            const ctx = initSFX();
            if (ctx.state === 'suspended') ctx.resume();

            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(300, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
            osc.start();
            osc.stop(ctx.currentTime + 0.3);
        }

        function playLinesSound() {
            if (!state.sfxEnabled) return;
            playTone(800, 0.1, 'sine', 0.15);
            setTimeout(() => playTone(1000, 0.1, 'sine', 0.1), 50);
            setTimeout(() => playTone(1200, 0.15, 'sine', 0.1), 100);
        }

        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                audioData = new Uint8Array(analyser.frequencyBinCount);
                document.getElementById('audio-indicator').style.display = 'flex';
                return true;
            } catch (e) {
                console.error('Audio init failed:', e);
                return false;
            }
        }

        function updateAudio() {
            if (!analyser || !state.audioEnabled) {
                state.audioLevel = 0;
                return;
            }

            analyser.getByteFrequencyData(audioData);

            // Calculate average level
            let sum = 0;
            for (let i = 0; i < audioData.length; i++) {
                sum += audioData[i];
            }
            state.audioLevel = (sum / audioData.length) / 255;

            // Update audio bars
            const bars = document.querySelectorAll('.audio-bar');
            const step = Math.floor(audioData.length / bars.length);
            bars.forEach((bar, i) => {
                const value = audioData[i * step] / 255;
                bar.style.height = (5 + value * 25) + 'px';
                bar.style.background = `hsl(${180 + value * 60}, 100%, 50%)`;
            });
        }

        // ========================================
        // HAND CONNECTIONS FOR OVERLAY
        // ========================================
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [0, 9], [9, 10], [10, 11], [11, 12],
            [0, 13], [13, 14], [14, 15], [15, 16],
            [0, 17], [17, 18], [18, 19], [19, 20],
            [5, 9], [9, 13], [13, 17]
        ];

        const FACE_CONTOUR = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288,
            397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136,
            172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ];

        // ========================================
        // MEDIAPIPE SETUP
        // ========================================
        const videoElement = document.getElementById('input-video');
        const overlayCanvas = document.getElementById('overlay-canvas');
        const overlayCtx = overlayCanvas.getContext('2d');

        let lastHandResults = null;
        let lastFaceResults = null;
        let handsReady = false;
        let faceReady = false;

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            handsReady = true;
            lastHandResults = results;
            tryProcessResults();
        });

        const faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        faceMesh.onResults((results) => {
            faceReady = true;
            lastFaceResults = results;
            tryProcessResults();
        });

        function tryProcessResults() {
            try {
                processAllResults();
            } catch (e) {
                console.error('Error in processAllResults:', e);
                document.getElementById('detection-status').textContent = 'Error: ' + e.message;
            }
        }

        // ========================================
        // GESTURE DETECTION
        // ========================================
        function detectFist(landmarks) {
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let curled = 0;
            for (let i = 0; i < tips.length; i++) {
                if (landmarks[tips[i]].y > landmarks[pips[i]].y) curled++;
            }
            return curled >= 3;
        }

        function detectPeaceSign(landmarks) {
            // Index and middle fingers extended, others curled
            const indexExtended = landmarks[8].y < landmarks[6].y;
            const middleExtended = landmarks[12].y < landmarks[10].y;
            const ringCurled = landmarks[16].y > landmarks[14].y;
            const pinkyCurled = landmarks[20].y > landmarks[18].y;

            return indexExtended && middleExtended && ringCurled && pinkyCurled;
        }

        function detectOpenHand(landmarks) {
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let extended = 0;
            for (let i = 0; i < tips.length; i++) {
                if (landmarks[tips[i]].y < landmarks[pips[i]].y) extended++;
            }
            return extended >= 4;
        }

        function detectMouthOpen(faceLM) {
            if (!faceLM) return false;
            // Upper lip: 13, Lower lip: 14
            const upperLip = faceLM[13];
            const lowerLip = faceLM[14];
            const noseTip = faceLM[1];
            const chin = faceLM[152];

            const mouthHeight = Math.abs(lowerLip.y - upperLip.y);
            const faceHeight = Math.abs(chin.y - noseTip.y);

            return mouthHeight / faceHeight > 0.15;
        }

        // ========================================
        // PROCESS RESULTS
        // ========================================
        function processAllResults() {
            const newTargets = [];
            state.handsDetected = 0;
            state.faceDetected = false;
            state.currentGesture = 'NONE';
            state.peaceSign = false;

            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            const scaleX = screenW * 0.8;
            const scaleY = screenH * 0.8;

            // Process hands
            if (lastHandResults && lastHandResults.multiHandLandmarks) {
                state.handsDetected = lastHandResults.multiHandLandmarks.length;

                for (const landmarks of lastHandResults.multiHandLandmarks) {
                    for (const lm of landmarks) {
                        newTargets.push({
                            x: (0.5 - lm.x) * scaleX,
                            y: (0.5 - lm.y) * scaleY,
                            z: -lm.z * 100
                        });
                    }

                    // Interpolated points
                    for (const [start, end] of HAND_CONNECTIONS) {
                        const p1 = landmarks[start];
                        const p2 = landmarks[end];
                        for (let t = 0.25; t <= 0.75; t += 0.25) {
                            newTargets.push({
                                x: (0.5 - (p1.x + (p2.x - p1.x) * t)) * scaleX,
                                y: (0.5 - (p1.y + (p2.y - p1.y) * t)) * scaleY,
                                z: -(p1.z + (p2.z - p1.z) * t) * 100
                            });
                        }
                    }

                    // Gesture detection
                    if (detectFist(landmarks)) {
                        state.currentGesture = 'FIST';
                        if (state.themeCooldown <= 0) {
                            cycleTheme();
                            state.themeCooldown = 60;
                        }
                    } else if (detectPeaceSign(landmarks)) {
                        state.currentGesture = 'PEACE';
                        state.peaceSign = true;
                        if (state.gestureCooldown <= 0) {
                            triggerFireworks();
                            state.gestureCooldown = 30;
                        }
                    } else if (detectOpenHand(landmarks)) {
                        state.currentGesture = 'OPEN';
                    }
                }
            }

            // Process face
            if (lastFaceResults && lastFaceResults.multiFaceLandmarks && lastFaceResults.multiFaceLandmarks.length > 0) {
                state.faceDetected = true;
                const faceLM = lastFaceResults.multiFaceLandmarks[0];

                // Check for mouth open (vortex trigger)
                state.mouthOpen = detectMouthOpen(faceLM);
                if (state.mouthOpen) {
                    state.currentGesture = 'MOUTH OPEN';
                }

                // All face points
                for (let idx = 0; idx < faceLM.length; idx++) {
                    const lm = faceLM[idx];
                    newTargets.push({
                        x: (0.5 - lm.x) * scaleX,
                        y: (0.5 - lm.y) * scaleY,
                        z: -lm.z * 100
                    });
                }

                // Weighted features
                const leftEye = [33, 246, 161, 160, 159, 158, 157, 173, 133, 155, 154, 153, 145, 144, 163, 7];
                const rightEye = [362, 398, 384, 385, 386, 387, 388, 466, 263, 249, 390, 373, 374, 380, 381, 382];
                const lipsOuter = [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 409, 270, 269, 267, 0, 37, 39, 40, 185];
                const lipsInner = [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308, 415, 310, 311, 312, 13, 82, 81, 80, 191];
                const nose = [168, 6, 197, 195, 5, 4, 1, 19, 94, 2];
                const faceOval = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109];

                const addPoints = (indices, times) => {
                    for (let t = 0; t < times; t++) {
                        for (const idx of indices) {
                            const lm = faceLM[idx];
                            if (lm) {
                                newTargets.push({
                                    x: (0.5 - lm.x) * scaleX,
                                    y: (0.5 - lm.y) * scaleY,
                                    z: -lm.z * 100
                                });
                            }
                        }
                    }
                };

                addPoints(leftEye, 3);
                addPoints(rightEye, 3);
                addPoints(lipsOuter, 3);
                addPoints(lipsInner, 2);
                addPoints(nose, 2);
                addPoints(faceOval, 2);
            }

            state.targetPoints = newTargets;
            document.getElementById('gesture').textContent = state.currentGesture;
            updateStatus();
            drawOverlay();
        }

        // ========================================
        // EFFECTS
        // ========================================
        function triggerFireworks() {
            showEffect('FIREWORKS!');
            playFireworksSound();
            // Create multiple explosions
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const x = (Math.random() - 0.5) * window.innerWidth * 0.6;
                    const y = (Math.random() - 0.5) * window.innerHeight * 0.4;
                    createExplosion(x, y, false); // No sound for individual firework explosions
                }, i * 100);
            }
        }

        function createExplosion(x, y, playSound = true) {
            state.explosions.push({
                x, y,
                force: CONFIG.explosionForce,
                time: 0
            });
            if (playSound) playExplosionSound();
        }

        function showEffect(text) {
            const el = document.getElementById('effect-indicator');
            el.textContent = text;
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 1000);
        }

        function cycleTheme() {
            state.themeIndex = (state.themeIndex + 1) % THEMES.length;
            const themeName = THEMES[state.themeIndex].name;
            document.getElementById('theme-name').textContent = themeName;
            showEffect(themeName + ' THEME');
            playThemeSound(state.themeIndex);

            const themeColors = {
                'RAINBOW': '#FF00FF',
                'FIRE': '#FF4500',
                'OCEAN': '#00FFFF',
                'GALAXY': '#9400D3',
                'MATRIX': '#00FF00'
            };
            document.getElementById('theme-name').style.color = themeColors[themeName];
        }

        function updateStatus() {
            const el = document.getElementById('detection-status');
            const parts = [];
            if (state.handsDetected > 0) parts.push(`${state.handsDetected} hand${state.handsDetected > 1 ? 's' : ''}`);
            if (state.faceDetected) parts.push('face');
            el.textContent = parts.length > 0 ? parts.join(' + ') : 'No detection';

            const dot = document.querySelector('.status-dot');
            dot.style.background = parts.length > 0 ? '#00FF88' : '#FF4444';
        }

        function drawOverlay() {
            if (!state.cameraVisible) return;

            overlayCanvas.width = overlayCanvas.clientWidth;
            overlayCanvas.height = overlayCanvas.clientHeight;
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            const themeColors = {
                'RAINBOW': '#FF00FF',
                'FIRE': '#FF4500',
                'OCEAN': '#00FFFF',
                'GALAXY': '#9400D3',
                'MATRIX': '#00FF00'
            };
            const color = themeColors[THEMES[state.themeIndex].name];

            // Draw hands
            if (lastHandResults && lastHandResults.multiHandLandmarks) {
                for (const landmarks of lastHandResults.multiHandLandmarks) {
                    overlayCtx.strokeStyle = color;
                    overlayCtx.lineWidth = 2;

                    for (const [start, end] of HAND_CONNECTIONS) {
                        const p1 = landmarks[start];
                        const p2 = landmarks[end];
                        overlayCtx.beginPath();
                        overlayCtx.moveTo(p1.x * overlayCanvas.width, p1.y * overlayCanvas.height);
                        overlayCtx.lineTo(p2.x * overlayCanvas.width, p2.y * overlayCanvas.height);
                        overlayCtx.stroke();
                    }

                    overlayCtx.fillStyle = color;
                    for (const lm of landmarks) {
                        overlayCtx.beginPath();
                        overlayCtx.arc(lm.x * overlayCanvas.width, lm.y * overlayCanvas.height, 3, 0, Math.PI * 2);
                        overlayCtx.fill();
                    }
                }
            }

            // Draw face
            if (lastFaceResults && lastFaceResults.multiFaceLandmarks && lastFaceResults.multiFaceLandmarks.length > 0) {
                const faceLM = lastFaceResults.multiFaceLandmarks[0];
                overlayCtx.strokeStyle = color;
                overlayCtx.globalAlpha = 0.7;
                overlayCtx.lineWidth = 1.5;

                overlayCtx.beginPath();
                for (let i = 0; i < FACE_CONTOUR.length; i++) {
                    const lm = faceLM[FACE_CONTOUR[i]];
                    if (lm) {
                        const x = lm.x * overlayCanvas.width;
                        const y = lm.y * overlayCanvas.height;
                        if (i === 0) overlayCtx.moveTo(x, y);
                        else overlayCtx.lineTo(x, y);
                    }
                }
                overlayCtx.closePath();
                overlayCtx.stroke();
                overlayCtx.globalAlpha = 1;
            }
        }

        // ========================================
        // CONNECTION LINES
        // ========================================
        function drawConnectionLines() {
            linesCtx.clearRect(0, 0, linesCanvas.width, linesCanvas.height);

            if (!state.linesEnabled) return;

            const posArr = geometry.attributes.position.array;
            const colArr = geometry.attributes.color.array;
            const centerX = linesCanvas.width / 2;
            const centerY = linesCanvas.height / 2;

            let connectionCount = 0;
            const maxDist = CONFIG.connectionDistance;

            // Sample particles for performance
            const sampleRate = 20;

            for (let i = 0; i < CONFIG.particleCount && connectionCount < CONFIG.maxConnections; i += sampleRate) {
                const i3 = i * 3;
                const x1 = posArr[i3] + centerX;
                const y1 = -posArr[i3 + 1] + centerY;

                for (let j = i + sampleRate; j < CONFIG.particleCount && connectionCount < CONFIG.maxConnections; j += sampleRate) {
                    const j3 = j * 3;
                    const x2 = posArr[j3] + centerX;
                    const y2 = -posArr[j3 + 1] + centerY;

                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < maxDist) {
                        const alpha = (1 - dist / maxDist) * 0.3;
                        const r = Math.floor(colArr[i3] * 255);
                        const g = Math.floor(colArr[i3 + 1] * 255);
                        const b = Math.floor(colArr[i3 + 2] * 255);

                        linesCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        linesCtx.beginPath();
                        linesCtx.moveTo(x1, y1);
                        linesCtx.lineTo(x2, y2);
                        linesCtx.stroke();
                        connectionCount++;
                    }
                }
            }
        }

        // ========================================
        // ANIMATION LOOP
        // ========================================
        let lastTime = performance.now();
        let frameCount = 0;

        function animate() {
            requestAnimationFrame(animate);

            state.time += 0.016;
            state.pulsePhase += 0.016 * CONFIG.pulseSpeed;
            if (state.themeCooldown > 0) state.themeCooldown--;
            if (state.gestureCooldown > 0) state.gestureCooldown--;

            // Update audio
            updateAudio();

            // Update shader uniforms
            material.uniforms.uTime.value = state.time;
            material.uniforms.uPulse.value = 1.0 + state.audioLevel * 0.5;

            // FPS
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }

            // Update explosions
            state.explosions = state.explosions.filter(exp => {
                exp.force *= CONFIG.explosionDecay;
                exp.time++;
                return exp.force > 1;
            });

            updateParticles();
            updateTrails();
            drawConnectionLines();
            renderer.render(scene, camera);
        }

        function updateParticles() {
            const posArr = geometry.attributes.position.array;
            const colArr = geometry.attributes.color.array;
            const sizeArr = geometry.attributes.size.array;
            const targets = state.targetPoints;
            const hasTargets = targets.length > 0;
            const theme = THEMES[state.themeIndex];

            // Get mouth position for vortex
            let mouthX = 0, mouthY = 0;
            if (state.mouthOpen && lastFaceResults && lastFaceResults.multiFaceLandmarks && lastFaceResults.multiFaceLandmarks.length > 0) {
                const faceLM = lastFaceResults.multiFaceLandmarks[0];
                const mouth = faceLM[13]; // Upper lip center
                mouthX = (0.5 - mouth.x) * window.innerWidth * 0.8;
                mouthY = (0.5 - mouth.y) * window.innerHeight * 0.8;
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;

                // Store previous position for trails
                prevPositions[i3] = posArr[i3];
                prevPositions[i3 + 1] = posArr[i3 + 1];
                prevPositions[i3 + 2] = posArr[i3 + 2];

                let px = posArr[i3];
                let py = posArr[i3 + 1];
                let pz = posArr[i3 + 2];

                // Apply explosion forces
                for (const exp of state.explosions) {
                    const dx = px - exp.x;
                    const dy = py - exp.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                    if (dist < 300) {
                        const force = exp.force / dist;
                        px += (dx / dist) * force * 0.5;
                        py += (dy / dist) * force * 0.5;
                    }
                }

                // Mouth vortex effect
                if (state.mouthOpen) {
                    const dx = mouthX - px;
                    const dy = mouthY - py;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200 && dist > 10) {
                        // Spiral toward mouth
                        const angle = Math.atan2(dy, dx);
                        const spiralAngle = angle + 0.3;
                        const force = (1 - dist / 200) * 8;
                        px += Math.cos(spiralAngle) * force;
                        py += Math.sin(spiralAngle) * force;
                    }
                }

                if (hasTargets) {
                    if (state.mode === 'ATTRACT') {
                        const targetIdx = i % targets.length;
                        const target = targets[targetIdx];

                        let spread = 3 + (i % 4) * 1.5;
                        spread += state.audioLevel * 10; // Audio reactive spread

                        const baseAngle = i * 0.618033 * Math.PI * 2;
                        let angle = baseAngle + state.time * 0.3;

                        // Spiral effect
                        if (state.spiralEnabled) {
                            angle += state.time * CONFIG.spiralSpeed;
                            spread += Math.sin(state.time * 2 + i * 0.1) * 5;
                        }

                        const offsetX = Math.cos(angle) * spread;
                        const offsetY = Math.sin(angle) * spread;
                        const offsetZ = Math.sin(i * 0.05 + state.time) * 8;

                        const tx = target.x + offsetX;
                        const ty = target.y + offsetY;
                        const tz = target.z + offsetZ;

                        px += (tx - px) * CONFIG.lerpSpeed * 1.2;
                        py += (ty - py) * CONFIG.lerpSpeed * 1.2;
                        pz += (tz - pz) * CONFIG.lerpSpeed;

                    } else { // REPEL
                        let fx = 0, fy = 0;
                        for (const target of targets) {
                            const dx = px - target.x;
                            const dy = py - target.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < CONFIG.attractRadius && dist > 1) {
                                const force = (1 - dist / CONFIG.attractRadius) * CONFIG.repelForce;
                                fx += (dx / dist) * force;
                                fy += (dy / dist) * force;
                            }
                        }
                        px += fx * 0.1;
                        py += fy * 0.1;
                        px += Math.sin(state.time + i * 0.01) * 0.5;
                        py += Math.cos(state.time * 0.8 + i * 0.01) * 0.5;
                    }
                } else {
                    px += Math.sin(state.time * 0.5 + i * 0.01) * 0.3;
                    py += Math.cos(state.time * 0.4 + i * 0.013) * 0.3;
                    pz += Math.sin(state.time * 0.3 + i * 0.007) * 0.2;
                }

                // Calculate velocity
                velocities[i3] = px - prevPositions[i3];
                velocities[i3 + 1] = py - prevPositions[i3 + 1];
                velocities[i3 + 2] = pz - prevPositions[i3 + 2];

                // Bounds
                const maxX = window.innerWidth * 0.6;
                const maxY = window.innerHeight * 0.5;
                if (Math.abs(px) > maxX) px *= 0.98;
                if (Math.abs(py) > maxY) py *= 0.98;
                if (Math.abs(pz) > 150) pz *= 0.95;

                posArr[i3] = px;
                posArr[i3 + 1] = py;
                posArr[i3 + 2] = pz;

                // Colors with audio reactivity
                const [r, g, b] = theme.getColor(i, state.time, state.audioLevel);

                // Sparkle effect - random particles flash brighter
                let sparkleBoost = 0;
                if (Math.random() < CONFIG.sparkleChance) {
                    sparkleBoost = 0.5;
                    state.sparkles.add(i);
                }
                if (state.sparkles.has(i)) {
                    sparkleBoost = Math.max(0, sparkleBoost - 0.05);
                    if (sparkleBoost <= 0) state.sparkles.delete(i);
                }

                colArr[i3] += (Math.min(r + sparkleBoost, 1) - colArr[i3]) * 0.1;
                colArr[i3 + 1] += (Math.min(g + sparkleBoost, 1) - colArr[i3 + 1]) * 0.1;
                colArr[i3 + 2] += (Math.min(b + sparkleBoost, 1) - colArr[i3 + 2]) * 0.1;

                // Pulse size effect
                const pulseSize = 0.5 + Math.sin(state.pulsePhase + i * 0.01) * 0.3;
                sizeArr[i] += (pulseSize - sizeArr[i]) * 0.1;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            geometry.attributes.size.needsUpdate = true;
        }

        function updateTrails() {
            if (!state.trailsEnabled) {
                trails.visible = false;
                return;
            }
            trails.visible = true;

            const posArr = geometry.attributes.position.array;
            const colArr = geometry.attributes.color.array;
            const trailPosArr = trailGeometry.attributes.position.array;
            const trailColArr = trailGeometry.attributes.color.array;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                const i6 = i * 6;

                // Current position
                trailPosArr[i6] = posArr[i3];
                trailPosArr[i6 + 1] = posArr[i3 + 1];
                trailPosArr[i6 + 2] = posArr[i3 + 2];

                // Trail end (previous position extended)
                const vx = velocities[i3] * CONFIG.trailLength;
                const vy = velocities[i3 + 1] * CONFIG.trailLength;
                const vz = velocities[i3 + 2] * CONFIG.trailLength;

                trailPosArr[i6 + 3] = posArr[i3] - vx;
                trailPosArr[i6 + 4] = posArr[i3 + 1] - vy;
                trailPosArr[i6 + 5] = posArr[i3 + 2] - vz;

                // Colors (fade trail end)
                trailColArr[i6] = colArr[i3];
                trailColArr[i6 + 1] = colArr[i3 + 1];
                trailColArr[i6 + 2] = colArr[i3 + 2];
                trailColArr[i6 + 3] = colArr[i3] * 0.3;
                trailColArr[i6 + 4] = colArr[i3 + 1] * 0.3;
                trailColArr[i6 + 5] = colArr[i3 + 2] * 0.3;
            }

            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.color.needsUpdate = true;
        }

        // ========================================
        // UI CONTROLS
        // ========================================
        document.getElementById('btn-attract').addEventListener('click', function() {
            state.mode = state.mode === 'ATTRACT' ? 'REPEL' : 'ATTRACT';
            this.textContent = state.mode === 'ATTRACT' ? 'Attract Mode' : 'Repel Mode';
            this.classList.toggle('active', state.mode === 'ATTRACT');
            showEffect(state.mode + ' MODE');
            playModeSound(state.mode === 'ATTRACT');
        });

        document.getElementById('btn-spiral').addEventListener('click', function() {
            state.spiralEnabled = !state.spiralEnabled;
            this.textContent = 'Spiral: ' + (state.spiralEnabled ? 'ON' : 'OFF');
            this.classList.toggle('active', state.spiralEnabled);
            if (state.spiralEnabled) {
                showEffect('SPIRAL VORTEX');
                playSpiralSound();
            }
        });

        document.getElementById('btn-trails').addEventListener('click', function() {
            state.trailsEnabled = !state.trailsEnabled;
            this.textContent = 'Trails: ' + (state.trailsEnabled ? 'ON' : 'OFF');
            this.classList.toggle('active', state.trailsEnabled);
            playTone(state.trailsEnabled ? 600 : 400, 0.1, 'sine', 0.15);
        });

        document.getElementById('btn-lines').addEventListener('click', function() {
            state.linesEnabled = !state.linesEnabled;
            this.textContent = 'Lines: ' + (state.linesEnabled ? 'ON' : 'OFF');
            this.classList.toggle('active', state.linesEnabled);
            if (state.linesEnabled) {
                showEffect('CONSTELLATION MODE');
                playLinesSound();
            }
        });

        document.getElementById('btn-audio').addEventListener('click', async function() {
            if (!state.audioEnabled) {
                const success = await initAudio();
                if (success) {
                    state.audioEnabled = true;
                    this.textContent = 'Audio: ON';
                    this.classList.add('active');
                    showEffect('AUDIO REACTIVE');
                    playTone(880, 0.15, 'sine', 0.2);
                }
            } else {
                state.audioEnabled = false;
                this.textContent = 'Audio: OFF';
                this.classList.remove('active');
                document.getElementById('audio-indicator').style.display = 'none';
                playTone(440, 0.15, 'sine', 0.2);
            }
        });

        document.getElementById('btn-sfx').addEventListener('click', function() {
            state.sfxEnabled = !state.sfxEnabled;
            this.textContent = 'SFX: ' + (state.sfxEnabled ? 'ON' : 'OFF');
            this.classList.toggle('active', state.sfxEnabled);
        });

        document.getElementById('btn-camera').addEventListener('click', function() {
            state.cameraVisible = !state.cameraVisible;
            document.getElementById('camera-container').classList.toggle('hidden', !state.cameraVisible);
            this.textContent = state.cameraVisible ? 'Hide Camera' : 'Show Camera';
        });

        // Click explosion
        document.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            const x = e.clientX - window.innerWidth / 2;
            const y = -(e.clientY - window.innerHeight / 2);
            createExplosion(x, y);
            showEffect('BOOM!');
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                document.getElementById('btn-attract').click();
            } else if (e.code === 'KeyS') {
                document.getElementById('btn-spiral').click();
            } else if (e.code === 'KeyT') {
                document.getElementById('btn-trails').click();
            } else if (e.code === 'KeyL') {
                document.getElementById('btn-lines').click();
            } else if (e.code === 'KeyA') {
                document.getElementById('btn-audio').click();
            } else if (e.code === 'KeyM') {
                document.getElementById('btn-sfx').click();
            } else if (e.code === 'KeyV') {
                document.getElementById('btn-camera').click();
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            linesCanvas.width = window.innerWidth;
            linesCanvas.height = window.innerHeight;
        });

        // ========================================
        // INITIALIZATION
        // ========================================
        async function init() {
            console.log('Starting initialization...');

            try {
                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        try {
                            await hands.send({ image: videoElement });
                        } catch (e) {}
                        try {
                            await faceMesh.send({ image: videoElement });
                        } catch (e) {}
                    },
                    width: 640,
                    height: 480,
                    facingMode: 'user'
                });

                console.log('Starting camera...');
                await cameraUtils.start();
                console.log('Camera started');

                state.initialized = true;
                document.getElementById('loading').style.display = 'none';
                document.getElementById('detection-status').textContent = 'Waiting for detection...';

                // Set initial button states
                document.getElementById('btn-trails').classList.add('active');

                animate();

            } catch (err) {
                console.error('Init error:', err);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #FF4444;">ERROR: ${err.message}</div>
                    <div style="margin-top: 10px; font-size: 12px;">Please allow camera access and refresh</div>
                `;
            }
        }

        init();
    </script>
</body>
</html>
